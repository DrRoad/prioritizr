% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solve.R
\name{solve}
\alias{solve}
\alias{solve,OptimizationProblem,Solver-method}
\alias{solve,ConservationProblem,missing-method}
\alias{solve}
\alias{solve}
\title{Solve a problem}
\arguments{
\item{a}{\code{\link{ConservationProblem-class}} or an
\code{\link{OptimizationProblem-class}} object.}

\item{b}{\code{\link{Solver-class}} object. Not used if \code{a} is an
\code{\link{ConservationProblem-class}} object.}

\item{...}{arguments passed to \code{\link{compile}}.}
}
\value{
A \code{numeric}, \code{matrix},
  \code{\link[raster]{RasterLayer-class}}, or
  \code{\link[sp]{Spatial-class}} object containing the solution to
  the problem.
}
\description{
Solve a \code{\link{ConservationProblem-class}} or an
\code{\link{OptimizationProblem-class}} object.
}
\details{
The object returned from this function depends on the argument to
  \code{a}. If the argument to \code{a} is an
  \code{\link{OptimizationProblem-class}} object, then the
  solution is returned as a \code{logical} \code{vector} showing the status
  of each planning unit in each zone. On the other hand, if the argument
  to \code{a} is an \code{\link{ConservationProblem-class}} object,
  then the type of object returned depends on the number of solutions
  generated and the type data used to represent planning unit costs in the
  argument to \code{a}.

  \describe{

  \item{\code{numeric}}{\code{vector} containing the solution. Here,
    Each element corresponds to a different planning unit. If
    multiple solutions are generated, then the solution is returned as
    a \code{list} of \code{numeric} \code{vectors}.}

  \item{\code{matrix}}{containing \code{numeric} values for the solution.
    Here, rows correspond to different planning units,
    and fields (columns) correspond to different  management zones. If
    multiple solutions are generated, then the solution is returned as
    a \code{list} of \code{matrix} objects.}

  \item{\code{\link[raster]{Raster}}}{containing the solution in pixel
     values. If the argument to \code{x} contains a single management zone,
     then a \code{RasterLayer} object will be returned. Otherwise, if the
     argument to \code{x} contains multiple zones, then a
     \code{\link[raster]{RasterStack-class}} object
     will be returned containing a different layer for each management zone.
     If multiple solutions are generated, then the solution is returned as
     a \code{list} of \code{Raster} objects.}

  \item{\code{\link[sp]{Spatial-class}} or \code{data.frame}}{
     containing the solution in fields (columns). Here, each row
     corresponds to a different planning unit. If the argument to \code{x}
     contains a single zone, the fields containing solutions are named
     \code{"solution_XXX"} where \code{"XXX"} corresponds to the solution
     number. If the argument to \code{x} contains multiple zones, the fields
     containing solutions are named \code{"solution_XXX_YYY"} where
     \code{"XXX"} corresponds to the solution and \code{"YYY"} is the name
     of the management zone.}

  }

Since this function returns an object that specifies how much of each
planning unit is allocated to each management zone, it may be useful to use
the \code{\link{categorize_by_zone}} function to reformat the output
for problems containing multiple zones.
}
\examples{
# build minimal conservation problem
p <- problem(sim_pu_raster, sim_features) \%>\%
  add_min_set_objective() \%>\%
  add_relative_targets(0.1) \%>\%
  add_binary_decisions()

\donttest{
# solve the problem
s <- solve(p)

# print the solution
print(s)

# plot solution
plot(s, main = "solution", axes = FALSE, box = FALSE)
}

}
\seealso{
\code{\link{problem}}, \code{\link{solvers}},
  \code{\link{categorize_by_zone}}
}
